.. About this 
  contains one (!) glosssary entry. The content will be fetched 
  by a `include` directive of Sphinx to build up the glossary
  write 0 whitespaces in front of the label
  write 2 whitespaces in front of description.

.. _dylan-term-class:

class
-----


  :samp:`define class` introduces in the dylan language the :ref:`definition
  <dylan-term-definition>` 
  of a *class*.  

.. _dylan-term-class(views):
  
  We introduce several views on a *class* from different
  perspectives. This provides a better understanding 
  of the dylan language construct *class*:

  - Related to the core concept :ref:`binding
    <dylan-term-binding>` 
    of the dylan language one  can describe a class as: 
    
    -  *grouping mechanism for* :term:`bindings 
       <dylan-term-binding>`. 

  - The *class* concept in the dylan language 
    has its roots in the fields of 
    *Artificial Intelligence (AI)* and 
    *Knowledge Represenation (KR)*:
    
    - The concept of a *frame* in AI and KR is well resembled by the
      *class* concept of the dylan language:

      - What a *frame*  does in Knowledge Representation - 
        containing a set of 
        :ref:`named
        <dylan-term-name>` 
        :ref:`slots 
        <dylan-term-slot>`   - 
        does represent a *class* in the dylan language. 
    
  - The *class* concept in the dylan language 
    is a respecter of :ref:`separation of concerns
    <dylan-term-separation-of-concerns>`:

    - The dylan language uses a class as grouping mechanism for bindings 
      only, and *not* as a construct to build up a :ref:`namespace
      <dylan-term-namespace>` 
      or a 
      :ref:`compilation unit
      <dylan-term-compilation-unit>`
      .
     
      More explained in the paragraph *object model* :ref:`below 
      <dylan-term-class(object-modell)>`
     
  - The dylan language implements the 
    :ref:`object-oriented paradigma of programming
    <dylan-term-object-oriented-paradigma-of-programming>`, 
    but its design is *centered around methods*, 
    not centered around *classes* as it is 
    done in the current mainstream object-oriented languages. 

.. _dylan-term-class(object-model):

  The :ref:`object model
  <dylan-term-object-model>` 
  often feels strange to newcomer to the dylan language from the 
  current mainstream object-oriented languages (C#, Java).
  
  - To build up a namespace around a class: 
   
    - in the dylan language you will define a :ref:`module
      <dylan-term-module>`  
      and nest the class inside the module.
  
  - To build up a :ref:`compilation unit
    <dylan-term-compilation-unit>` 
 
    - in the dylan language you will defines a :ref:`library
      <dylan-term-library>`, which groups together your :ref:`modules
      <dylan-term-module>`, which represent :ref:`namespaces
      <dylan-term-namespaces>`
      .
 
  - To initialise a class
   
    - in the dylan language you will :ref:`generic function
      <dylan-term-generic-function>` 
      :samp:`initialize`, which is outside of 
      the :samp:`define class` construct.


.. _dylan-term-class(make):

  - To create an instance creation of a class

    - you will in the dylan language the *class* as first
      argument to the :ref:`generic function
      <dylan-term-generic-function>` 
      :samp:`make`. The object returned by *make* is 
      guaranteed to be a general instance of the first
      argument to *make*, but not nessarily a direct
      instance.


      Notes:

.. _dylan-term-class(abstract-concrete):

      - A *abstract* class cannot have *direct instances*
        as the opposite, a *concrete* class, can have.

        The object that *make* returns is a *general* instance
        of its first argument (see :ref:`above
        <dylan-term-class(make)>`). This liberality allows
        *make* to be called on an abstract class:

	- *make* can instantiate and return a direct instance
          of one of the concrete subclasses of the abstract
          class.


.. _dylan-term-class(instantiable-uninstantiable):

      - Only instantiable classes can be used as first
        argument for *make*.  

	 - A class is :ref:`sealed
           <dylan-term-sealing>` for the use as
           first argument to *make*, when the class
           definition uses the adjective 
           *uninstantiable*. The default is: *instantiable*


.. _dylan-term-class(slot):
  
  A *slot* of a class can either 
  
  - bind a *data* or 
  - bind a *method*, 

  as both are :ref:`first class objects
  <dylan-term-first-class-object>` 
  in the dylan language.

.. _dylan-term-class(slot-the-sole-class-construct):

  What is astonishing to newcomers to the dylan language
  is
  
  -  there exists only one construct, :ref:`slot
     <dylan-term-slot>`
     to build up the content of a class.
  
.. _dylam-term-class(guide-to-subordinates):

  Subordinated topics to a :ref:`class
  <dylan-term-class>`
  are:

  - The specification of :ref:`slots
    <dylan-term-slot>` of class.
    
  - a class definition can specify adjectives to support 
    :ref:`sealing techniques
    <dylan-term-sealing>` related to :ref:`instance creation
    <dylan-term-class(make)>`

    - A class can be declared as *concrete*, which means that direct 
      instance creation is allowed. 
      Or it can be declared as *abstract*, which means that only 
      general instance creation is allowed.
     
    - A class may declare to use of the class as first argument to 
      *make* as allowed (*instantiable* class)
      or as disallowed (*uninstantiable* class).
   
      - Note: a *abstract* class can be *instantiable* by
        *make* and will return a *general instance* of the
        abstract class. 

  - A class definition can specify adjectives to support 
    ref:`sealing techniques
    <dylan-term-sealing>` related to:ref:`class inheritance
    <dylan-term-class-inheritance>`, also known as 
    :ref:`subclassing
    <dylan-term-subclassing>`. 

    -  A class might be declared *sealed* or *open*
       for subclassing
    
    The dylan language supports a special form of :ref:`class inheritance
    <dylan-term-class-inheritance>`: :ref:`multi-inheritance
    <dylan-term-multi-inheritance>`.
 
    - A class might be declared *primary* or *free* for multi-inheritance.
      Primary classes form a single inheritance chain.
      The default is: *free* 
